<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>iRonhead</title>
    <description>wait.
</description>
    <link>http://ironhead.bitbucket.com/</link>
    <atom:link href="http://ironhead.bitbucket.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 23 Apr 2015 15:23:21 +0800</pubDate>
    <lastBuildDate>Thu, 23 Apr 2015 15:23:21 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>Arduino SSD1306 LED</title>
        <description>&lt;p&gt;A more simple version of &lt;a href=&quot;http://www.instructables.com/id/How-to-use-OLED-display-arduino-module/&quot;&gt;Instructables example&lt;/a&gt;.
For me, the most interesting part is the speeds to fill 1 byte ad fill 128 bytes in the same page
are almost the same.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/arduino_ssd1306.jpg&quot; alt=&quot;arduino + ssd1306&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;// SSD1306
// https://www.adafruit.com/datasheets/SSD1306.pdf
// 5v

#define PIN_DATA_COMMAND  (11)
#define PIN_RESET         (13)
#define PIN_SCL           (10)
#define PIN_SDA           (9)

void led_send(bool is_data, uint8_t data) {
  if (is_data) {
    digitalWrite(PIN_DATA_COMMAND, HIGH);
  } else {
    digitalWrite(PIN_DATA_COMMAND, LOW);
  }

  for (int i = 0; i &amp;lt; 8; ++i) {
    digitalWrite(PIN_SCL, LOW);

    if (data &amp;amp; 0x80) {
      digitalWrite(PIN_SDA, 1);
    } else {
      digitalWrite(PIN_SDA, 0);
    }

    digitalWrite(PIN_SCL, HIGH);

    data &amp;lt;&amp;lt;= 1;
  }
}

void led_send_data(uint8_t data) {
  led_send(true, data);
}

void led_send_command(uint8_t command) {
  led_send(false, command);
}

void led_init() {
  digitalWrite(PIN_SCL, HIGH);
  digitalWrite(PIN_RESET, LOW);
  delay(50);
  digitalWrite(PIN_RESET, HIGH);
  digitalWrite(PIN_SCL, LOW);

  // display off (sleep mode)
  led_send_command(0xae);

  // segment remap (?)
  led_send_command(0xa1);

  // VCOMH deselect level (?)
  led_send_command(0xdb);
  led_send_command(0x40);

  // pre-charge period
  // http://en.wikipedia.org/wiki/Pre-charge
  led_send_command(0xd9);
  led_send_command(0xf1);

  // COM pins hardware configuration (?)
  led_send_command(0xda);
  led_send_command(0x12);

  // memory addressing mode
  // 0x00 : horizontal
  // 0x01 : vertical
  // 0x02 : page
  led_send_command(0x20);
  led_send_command(0x02);

  // enable charge pump, dc/dc converter
  // http://en.wikipedia.org/wiki/Charge_pump
  led_send_command(0x8d);
  led_send_command(0x14);

  // display start line? (0x40 | (0 ~ 63))
  led_send_command(0x40 | 0);

  // display offset (vertical shift), 0 ~ 63
  led_send_command(0xd3);
  led_send_command(0x00);

  // multiplex ratio
  // http://en.wikipedia.org/wiki/Multiplexed_display
  led_send_command(0xa8);
  led_send_command(0x3f);

  // display clock divide ratio / oscillator frequency
  led_send_command(0xd5);
  led_send_command(0x80);

  // contrast
  // double byte, 2nd byte means contrast. Constrast increases as it increses.
  led_send_command(0x81);
  led_send_command(0x00);

  // entire display off
  // 0xa4 : pixels are on based on datas in RAM
  // 0xa5 : all pixels are on
  led_send_command(0xa4);

  // normal display
  // 0xa6 : bit 0 -&amp;gt; pixel off, bit 1 -&amp;gt; pixel on
  // 0xa7 : bit 1 -&amp;gt; pixel off, bit 0 -&amp;gt; pixel on
  led_send_command(0xa6);

  // display on (normal mode)
  led_send_command(0xaf);
}

void led_fill(const uint8_t* map) {
  uint8_t y;

  for (y = 0; y &amp;lt; 8; ++y) {
    led_send_command(0xb0 + y);
    led_send_command(0x01);
    led_send_command(0x10);

    for (int x = 0; x &amp;lt; 128; ++x) {
      led_send_data(*map++);
    }
  }
}

uint8_t led_set_pixel(uint8_t* map, int x, int y, uint8_t c) {
  // to page
  map += 128 * (y / 8);

  y %= 8;

  // to row
  map += x;

  // set col
  *map &amp;amp;= ~(1 &amp;lt;&amp;lt; y);
  *map |=  (c &amp;lt;&amp;lt; y);

  return *map;
}

uint8_t display_map[1024];

uint8_t pixel = 0;

void setup() {
  pinMode(PIN_SCL,OUTPUT);
  pinMode(PIN_SDA,OUTPUT);
  pinMode(PIN_RESET,OUTPUT);
  pinMode(PIN_DATA_COMMAND,OUTPUT);

  led_init();
  led_fill(display_map);
}

void loop() {
  pixel ^= 1;

  for (int y = 0 ; y &amp;lt; 64; ++y) {
    for (int x = 0; x &amp;lt; 128; ++x) {
      led_send_command(0xb0 + y / 8);
      led_send_command(0x00 + x % 16);
      led_send_command(0x10 + x / 16);

      led_send_data(led_set_pixel(display_map, x, y, pixel));

      delay(100);
    }
  }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Wed, 04 Mar 2015 00:00:00 +0800</pubDate>
        <link>http://ironhead.bitbucket.com/2015/03/04/arduino-33d1306.html</link>
        <guid isPermaLink="true">http://ironhead.bitbucket.com/2015/03/04/arduino-33d1306.html</guid>
        
        <category>arduinno</category>
        
        
      </item>
    
      <item>
        <title>CSRF of WebApp Frameworks</title>
        <description>&lt;h1 id=&quot;csrf-protection-in-rails-4-2-stable&quot;&gt;CSRF Protection in Rails (4-2-stable)&lt;/h1&gt;

&lt;h2 id=&quot;generate&quot;&gt;Generate&lt;/h2&gt;
&lt;p&gt;In rails, we can find a csrf token in the head of html or a hidden input of forms:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta name=&quot;csrf-token&quot;
          content=&quot;V6CZMZGA+lnkmonZbw74c81KAGjBAlK6Jk1UEbQkW95zjIMxU/G5ixcbokIG5GIzlG2gwtag4la/eLoTXT6/Dw==&quot; /&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;form&amp;gt;
      &amp;lt;input type=&quot;hidden&quot;
             name=&quot;authenticity_token&quot;
             value=&quot;OFkGlN+ho64ffPlNEJ7P01VPO+dC7yQ96rl13pKNV8McdRyUHdDgfOz90tZ5dFWTDGibTVVNlNFzjJvce5ezEg==&quot; /&amp;gt;
    &amp;lt;/form&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Those tokens are generated in &lt;a href=&quot;https://github.com/rails/rails/blob/4-2-stable/actionpack/lib/action_controller/metal/request_forgery_protection.rb&quot;&gt;ActionController&lt;/a&gt;
and not predictable (that’s what we need for csrf protection).
In &lt;a href=&quot;https://github.com/rails/rails/blob/4-2-stable/actionview/lib/action_view/helpers/csrf_helper.rb&quot;&gt;ActionView module&lt;/a&gt; we can find how csrf meta tags are generated:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def csrf_meta_tags
  if protect_against_forgery?
    [
      tag(&#39;meta&#39;, :name =&amp;gt; &#39;csrf-param&#39;, :content =&amp;gt; request_forgery_protection_token),
      tag(&#39;meta&#39;, :name =&amp;gt; &#39;csrf-token&#39;, :content =&amp;gt; form_authenticity_token)
    ].join(&quot;\n&quot;).html_safe
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The methods &lt;strong&gt;form_authenticity_token&lt;/strong&gt; is in &lt;a href=&quot;https://github.com/rails/rails/blob/4-2-stable/actionpack/lib/action_controller/metal/request_forgery_protection.rb&quot;&gt;ActionController&lt;/a&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;AUTHENTICITY_TOKEN_LENGTH = 32

def form_authenticity_token
  masked_authenticity_token(session)
end

def masked_authenticity_token(session)
  one_time_pad = SecureRandom.random_bytes(AUTHENTICITY_TOKEN_LENGTH)
  encrypted_csrf_token = xor_byte_strings(one_time_pad, real_csrf_token(session))
  masked_token = one_time_pad + encrypted_csrf_token
  Base64.strict_encode64(masked_token)
end

def valid_authenticity_token?(session, encoded_masked_token)
  return false if encoded_masked_token.nil? || encoded_masked_token.empty?

  begin
    masked_token = Base64.strict_decode64(encoded_masked_token)
  rescue ArgumentError # encoded_masked_token is invalid Base64
    return false
  end

  # See if it&#39;s actually a masked token or not. In order to
  # deploy this code, we should be able to handle any unmasked
  # tokens that we&#39;ve issued without error.

  if masked_token.length == AUTHENTICITY_TOKEN_LENGTH
    # This is actually an unmasked token. This is expected if
    # you have just upgraded to masked tokens, but should stop
    # happening shortly after installing this gem
    compare_with_real_token masked_token, session

  elsif masked_token.length == AUTHENTICITY_TOKEN_LENGTH * 2
    # Split the token into the one-time pad and the encrypted
    # value and decrypt it
    one_time_pad = masked_token[0...AUTHENTICITY_TOKEN_LENGTH]
    encrypted_csrf_token = masked_token[AUTHENTICITY_TOKEN_LENGTH..-1]
    csrf_token = xor_byte_strings(one_time_pad, encrypted_csrf_token)

    compare_with_real_token csrf_token, session

  else
    false # Token is malformed
  end
end

def real_csrf_token(session)
  session[:_csrf_token] ||= SecureRandom.base64(AUTHENTICITY_TOKEN_LENGTH)
  Base64.strict_decode64(session[:_csrf_token])
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In brief, a token is generated by this steps:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;For each session, a random 32 bytes long token in base 64 is generated (44 long).&lt;/li&gt;
  &lt;li&gt;Decode this token with base64 (to 32 bytes binary token).&lt;/li&gt;
  &lt;li&gt;Everytime when we need a form authenticity token, a 32 bytes one time pad is generated.&lt;/li&gt;
  &lt;li&gt;XOR one time pad and csrf token to encrypted_csrf_token.&lt;/li&gt;
  &lt;li&gt;Concatenate csrf token and encrypted_csrf_token (32 + 32 = 64 bytes).&lt;/li&gt;
  &lt;li&gt;Encode the result in base64 give us the final csrf token (64 * (4/3) = 88 bytes).&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;code-tracing-verification&quot;&gt;Code tracing verification&lt;/h2&gt;

&lt;p&gt;Now open a rails site in browser and find the csrf token, refresh the page to get 2 different tokens.
In rails console def a decode method and pass those tokens to see the result. The result should be the same.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# extract from valid_authenticity_token?
def decode(token)
  token = Base64.strict_decode64 token
  t1 = token[0...32]
  t2 = token[32..-1]
  t1.bytes.zip(t2.bytes).map { |(c1,c2)| c1 ^ c2 }.pack(&#39;c*&#39;)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then re-launch the browser and decode another token, the result should be changed (bound to session!).&lt;/p&gt;

&lt;h1 id=&quot;csrf-protection-in-nodejs&quot;&gt;CSRF Protection in Nodejs&lt;/h1&gt;

&lt;p&gt;In &lt;a href=&quot;https://github.com/expressjs/csurf/blob/master/index.js&quot;&gt;CSURF middleware&lt;/a&gt;, a secret is generated
using secretSync method of &lt;a href=&quot;https://github.com/pillarjs/csrf/blob/master/index.js&quot;&gt;csrf module&lt;/a&gt; which return
pseudo random bytes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// generate &amp;amp; set new secret
if (sec === undefined) {
  sec = tokens.secretSync()
  setsecret(req, res, sec, cookie)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in &lt;a href=&quot;https://github.com/pillarjs/csrf/blob/master/index.js&quot;&gt;csrf module&lt;/a&gt;, use tokenize method to generate
the final token:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;csrfTokens.tokenize = function tokenize(secret, salt) {
  var hash = escape(crypto
    .createHash(&#39;sha1&#39;)
    .update(salt)
    .update(&#39;-&#39;)
    .update(secret)
    .digest(&#39;base64&#39;))
  return salt + &#39;-&#39; + hash
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To verify the token, re-generate the token with salt and secret and compare the result. As in the
tokenize method, salt is in the beginning of the final token and hash is generated base on salt and
the pseudo randome secret.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;verify: function verify(secret, token) {
  if (!secret || typeof secret !== &#39;string&#39;) {
    return false
  }

  if (!token || typeof token !== &#39;string&#39;) {
    return false
  }

  var index = token.indexOf(&#39;-&#39;)

  if (index === -1) {
    return false
  }

  var salt = token.substr(0, index)
  var expected = tokenize(secret, salt)

  return scmp(token, expected)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;code-tracing-verification-1&quot;&gt;Code tracing verification&lt;/h2&gt;

&lt;p&gt;Can not verify if we don’t known the secret.&lt;/p&gt;

&lt;h1 id=&quot;references&quot;&gt;References&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/rails/rails/blob/4-2-stable/actionpack/lib/action_controller/metal/request_forgery_protection.rb&quot;&gt;Rails ActionController&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/pillarjs/csrf/blob/master/index.js&quot;&gt;Nodejs CSRF&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/expressjs/csurf/blob/master/index.js&quot;&gt;Nodejs CSURF&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 31 Jan 2015 00:00:00 +0800</pubDate>
        <link>http://ironhead.bitbucket.com/2015/01/31/webapp-csrf.html</link>
        <guid isPermaLink="true">http://ironhead.bitbucket.com/2015/01/31/webapp-csrf.html</guid>
        
        <category>nodejs</category>
        
        <category>rails</category>
        
        <category>programming</category>
        
        
      </item>
    
      <item>
        <title>Fibonacci in Go</title>
        <description>&lt;p&gt;Implement fibonacci to evaluate golang.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package main

import (
  &quot;fmt&quot;
  &quot;math/big&quot;
)


type M2 struct {
  e00, e01, e10, e11 big.Int
}

func NewM2(e00, e01, e10, e11 int64) *M2 {
  return &amp;amp;M2 {
    *big.NewInt(e00),
    *big.NewInt(e01),
    *big.NewInt(e10),
    *big.NewInt(e11) }
}

func (m *M2) String() string {
  return fmt.Sprintf(
    &quot;[[ %v, %v ], [ %v, %v ]]&quot;, &amp;amp;m.e00, &amp;amp;m.e01, &amp;amp;m.e10, &amp;amp;m.e11)
}

func Add(m, n *M2) *M2 {
  var r M2

  (&amp;amp;r.e00).Add(&amp;amp;m.e00, &amp;amp;n.e00)
  (&amp;amp;r.e01).Add(&amp;amp;m.e01, &amp;amp;n.e01)
  (&amp;amp;r.e10).Add(&amp;amp;m.e10, &amp;amp;n.e10)
  (&amp;amp;r.e11).Add(&amp;amp;m.e11, &amp;amp;n.e11)

  return &amp;amp;r
}

func Mul(m, n *M2) *M2 {
  var r M2

  (&amp;amp;r.e00).Add(new(big.Int).Mul(&amp;amp;m.e00, &amp;amp;n.e00),
               new(big.Int).Mul(&amp;amp;m.e01, &amp;amp;n.e10))
  (&amp;amp;r.e01).Add(new(big.Int).Mul(&amp;amp;m.e00, &amp;amp;n.e01),
               new(big.Int).Mul(&amp;amp;m.e01, &amp;amp;n.e11))
  (&amp;amp;r.e10).Add(new(big.Int).Mul(&amp;amp;m.e10, &amp;amp;n.e00),
               new(big.Int).Mul(&amp;amp;m.e11, &amp;amp;n.e10))
  (&amp;amp;r.e11).Add(new(big.Int).Mul(&amp;amp;m.e10, &amp;amp;n.e01),
               new(big.Int).Mul(&amp;amp;m.e11, &amp;amp;n.e11))

  return &amp;amp;r
}

func IsOdd(i *big.Int) bool {
  return 1 == new(big.Int).Mod(i, big.NewInt(2)).Cmp(big.NewInt(0))
}

func Pow(m *M2, p *big.Int) *M2 {
  if p.Cmp(big.NewInt(1)) == 0 {
    // should ???
    t := *m
    return &amp;amp;t
  } else {
    t := Pow(m, new(big.Int).Div(p, big.NewInt(2)))

    t = Mul(t, t)

    if IsOdd(p) {
      t = Mul(t, m)
    }

    return t
  }
}

func Fib(i *big.Int) *big.Int {
  return &amp;amp;Pow(NewM2(0, 1, 1, 1), i).e10
}

func main() {
  fmt.Println(Fib(big.NewInt(1000)))
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 26 Jan 2015 00:00:00 +0800</pubDate>
        <link>http://ironhead.bitbucket.com/2015/01/26/fibonacci-in-golang.html</link>
        <guid isPermaLink="true">http://ironhead.bitbucket.com/2015/01/26/fibonacci-in-golang.html</guid>
        
        <category>golang</category>
        
        <category>programming</category>
        
        
      </item>
    
      <item>
        <title>Sketch: Another Long Hair Girl</title>
        <description>&lt;p&gt;&lt;img src=&quot;/assets/images/sketch-0001.jpg&quot; alt=&quot;Another Long Hair Girl&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 17 Jan 2015 00:00:00 +0800</pubDate>
        <link>http://ironhead.bitbucket.com/2015/01/17/sketch.html</link>
        <guid isPermaLink="true">http://ironhead.bitbucket.com/2015/01/17/sketch.html</guid>
        
        <category>sketch</category>
        
        
      </item>
    
      <item>
        <title>Node.js Security Note</title>
        <description>&lt;h1 id=&quot;dependency&quot;&gt;Dependency&lt;/h1&gt;

&lt;p&gt;The version of express is 4.10.6. When this note was made, I still found many code samples for express 3. So I guess this note would also to be deprecated soon.&lt;/p&gt;

&lt;h1 id=&quot;reference&quot;&gt;Reference&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://cdn.oreillystatic.com/en/assets/1/event/106/Top%20Overlooked%20Security%20Threats%20To%20Node_js%20Web%20Applications%20Presentation%201.pdf&quot;&gt;Top Overlooked Security Threats To Node.js Web Applications&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;csrf&quot;&gt;CSRF&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/expressjs/csurf&quot;&gt;csurf: Node.js CSRF protection middleware&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// dependency
{
  &quot;dependencies&quot;: {
    &quot;csurf&quot;: &quot;^1.6.5&quot;
  }
}

// routes
app.use(csrf());
app.use(function(req, res, next) {
  var token = req.csrfToken();

  // for jade
  res.locals.csrfToken = token;
  // for Angularjs
  res.cookie(&#39;XSRF-TOKEN&#39;, token);

  next();
});
app.use(function(err, req, res, next) {
  // called if there are errors.
  if (err.code !== &quot;EBADCSRFTOKEN&quot;) {
    return next(err);
  }

  // handle CSRF token errors here
  res.status(403);
  res.send(&quot;leave me alone~~&quot;);

  console.log(&quot;bad csrf token&quot;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In forms with method “POST”, set a hidden field with name “_csrf”:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;form(method=&quot;post&quot;, action=&quot;/csrf&quot;)
  input(type=&quot;hidden&quot;, name=&quot;_csrf&quot;, value=&quot;#{ csrfToken }&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Angularjs read cookie ‘XSRF-TOKEN’ and send it back in header. Extra works are needed for jQuery.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;html
  head
    meta(name=&quot;csrf-token&quot;, content=&quot;#{ csrfToken }&quot;)

    script.
      $(document).ready(function (e) {
        $.ajaxPrefilter(function(options, _, xhr) {
          if (!xhr.crossDomain) {
            var token = $(&#39;meta[name=&quot;csrf-token&quot;]&#39;).attr(&#39;content&#39;);

            xhr.setRequestHeader(&quot;X-CSRF-Token&quot;, token);
          }
        });
      });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Note: Why setRequestHeader for jQuery&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;In most cases, setting _csrf in data field when post via ajax is enough. The problem surfaces when uploading files with “multipart/form-data”. If &lt;a href=&quot;https://github.com/andrewrk/node-multiparty/&quot;&gt;multiparty&lt;/a&gt; is used to handling file uploading, csrf checking happens before form processing which fails every time, because bodyparser ignore multipart form.&lt;/p&gt;

&lt;h1 id=&quot;expose-less-information-to-attackers&quot;&gt;Expose Less Information to Attackers&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var app = express();

// Disable the useless header &quot;x-powered-by&quot; whose value is &quot;Express&quot;.
app.disable(&quot;x-powered-by&quot;);

// The default session cookie key of express is &quot;connect.sid&quot;, change it.
// Secure cookie send session via https only.
// express session always set session a httponly cookie.
app.use(session({
  secret: &quot;do not touch me&quot;,
  key: &quot;session_id&quot;,
  cookie: {
    secure: true
  }
}));
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 17 Jan 2015 00:00:00 +0800</pubDate>
        <link>http://ironhead.bitbucket.com/2015/01/17/nodejs-security-note.html</link>
        <guid isPermaLink="true">http://ironhead.bitbucket.com/2015/01/17/nodejs-security-note.html</guid>
        
        <category>nodejs</category>
        
        <category>programming</category>
        
        
      </item>
    
      <item>
        <title>Conway&#39;s Game of Life on CodeSkulptor</title>
        <description>&lt;p&gt;&lt;a href=&quot;http://www.codeskulptor.org/#user38_iF5tSbexuT1XG1M_5.py&quot;&gt;CodeSkulptor&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import simplegui


class GameOfLife :
  def __init__(self, col_num, row_num, cell_size, line_size = 1) :
    self._col_num = col_num
    self._row_num = row_num
    self._cell_size = cell_size
    self._line_size = line_size

    self._cells = [[0] * col_num for _ in range(row_num)]

  def get_width(self) :
    return self._col_num * (self._cell_size + self._line_size) + self._line_size

  def get_height(self) :
    return self._row_num * (self._cell_size + self._line_size) + self._line_size

  def get_color_of_cell(self, x, y) :
    return &quot;Black&quot; if self._cells[y][x] == 0 else &quot;Lime&quot;

  def get_position_of_cell(self, x, y) :
    px = x * (self._line_size + self._cell_size) + self._line_size + 1
    py = y * (self._line_size + self._cell_size) + self._line_size + 1
    ww = self._cell_size - 2

    return [(px, py),  (px + ww, py), (px + ww, py + ww), (px, py + ww)]

  def reset(self) :
    for y in range(self._row_num) :
      for x in range(self._col_num) :
        self._cells[y][x] = 0

  def toggle_cell(self, x, y) :
    self._cells[y][x] = (1 + self._cells[y][x]) % 2

  def toggle_position(self, position) :
    s = self._line_size + self._cell_size
    x = position[0] / s
    y = position[1] / s

    if x &amp;lt; self._col_num and y &amp;lt; self._row_num and x &amp;gt;= 0 and y &amp;gt;= 0 :
      self.toggle_cell(x, y)

  def update(self) :
    temp = [[0] * self._col_num for _ in range(self._row_num)]

    for y in range(self._row_num) :
      for x in range(self._col_num) :
        z  = self._cells[y - 1][x - 1]
        z += self._cells[y - 1][x]
        z += self._cells[y][x - 1]
        z += self._cells[y][x]

        xx = 0 if x + 1 == self._col_num else x + 1
        yy = 0 if y + 1 == self._row_num else y + 1

        z += self._cells[y - 1][xx]
        z += self._cells[y][xx]
        z += self._cells[yy][x - 1]
        z += self._cells[yy][x]
        z += self._cells[yy][xx]

        temp[y][x] = z

    for y in range(self._row_num) :
      for x in range(self._col_num) :
        z = temp[y][x]

        if self._cells[y][x] == 1 :
          z -= 1

        if z &amp;lt; 2 :
          self._cells[y][x] = 0
        elif z &amp;lt; 4 :
          pass
        else :
          self._cells[y][x] = 0
        elif z == 3 :
          self._cells[y][x] = 1

  def draw(self, canvas) :
    width = self.get_width()

    y = self._line_size / 2

    for _ in range(1 + self._row_num) :
      canvas.draw_line((0, y), (width, y), self._line_size, &quot;Teal&quot;)

      y += self._cell_size + self._line_size

    height = self.get_height()

    x = self._line_size / 2

    for _ in range(1 + self._col_num) :
      canvas.draw_line((x, 0), (x, height), self._line_size, &quot;Teal&quot;)

      x += self._cell_size + self._line_size

    for y in range(self._row_num) :
      for x in range(self._col_num) :
        color = self.get_color_of_cell(x, y)

        canvas.draw_polygon(self.get_position_of_cell(x, y), 2, color, color)

button_start = None
button_clear = None
running = False

gol = GameOfLife(20, 20, 38, 2)

def demo(name) :
  global running

  running = True

  gol.reset()

  button_start.set_text(&quot;Pause&quot;)

  patterns = {
    &quot;toad&quot; : [(3, 2), (4, 2), (5, 2), (2, 3), (3, 3), (4, 3)],
    &quot;blinker&quot; : [(4, 3), (4, 4), (4, 5)],
    &quot;beacon&quot; : [(1, 1), (2, 1), (1, 2), (4, 4), (4, 3), (3, 4)],
    &quot;pulsar&quot; : [(4, 2), (5, 2), (6, 2), (10, 2), (11, 2), (12, 2), \
    (2, 4), (2, 5), (2, 6), (7, 4), (7, 5), (7, 6), \
    (9, 4), (9, 5), (9, 6), (14, 4), (14, 5), (14, 6), \
    (4, 7), (5, 7), (6, 7), (10, 7), (11, 7), (12, 7), \
    (4, 9), (5, 9), (6, 9), (10, 9), (11, 9), (12, 9), \
    (2, 10), (2, 11), (2, 12), (7, 10), (7, 11), (7, 12), \
    (9, 10), (9, 11), (9, 12), (14, 10), (14, 11), (14, 12), \
    (4, 14), (5, 14), (6, 14), (10, 14), (11, 14), (12, 14)],
    &quot;glider&quot; : [(5, 5), (6, 6), (6, 7), (5, 7), (4, 7)],
    &quot;lwss&quot; : [(2, 2), (2, 4), (5, 2), (6, 3), (6, 4), (6, 5), (3, 5), (4, 5), (5, 5)]
  }

  map(lambda x : gol.toggle_cell(x[0], x[1]), patterns[name])

def on_mouse_clicked(position) :
  if not running :
    gol.toggle_position(position)

def on_demo_toad() :
  demo(&quot;toad&quot;)

def on_demo_blinker() :
  demo(&quot;blinker&quot;)

def on_demo_beacon() :
  demo(&quot;beacon&quot;)

def on_demo_pulsar() :
  demo(&quot;pulsar&quot;)

def on_demo_glider() :
  demo(&quot;glider&quot;)

def on_demo_lwss() :
  demo(&quot;lwss&quot;)

def on_start() :
  global running

  running = not running

  if running :
    button_start.set_text(&quot;Pause&quot;)
  else :
    button_start.set_text(&quot;Start&quot;)

def on_clear() :
  global running

  running = False

  button_start.set_text(&quot;Start&quot;)

  gol.reset()

def update_game_of_life() :
  if running :
    gol.update()

def on_draw(canvas) :
  gol.draw(canvas)

# Create a frame and assign callbacks to event handlers
frame = simplegui.create_frame(&quot;Game of Life&quot;, gol.get_width(), gol.get_height())

frame.add_button(&#39;Demo Toad&#39;, on_demo_toad)
frame.add_button(&#39;Demo Blinker&#39;, on_demo_blinker)
frame.add_button(&#39;Demo Beacon&#39;, on_demo_beacon)
frame.add_button(&#39;Demo Pulsar&#39;, on_demo_pulsar)
frame.add_button(&#39;Demo Glider&#39;, on_demo_glider)
frame.add_button(&#39;Demo LWSS&#39;, on_demo_lwss)

button_start = frame.add_button(&#39;Start&#39;, on_start)
button_clear = frame.add_button(&#39;Clear&#39;, on_clear)

frame.set_mouseclick_handler(on_mouse_clicked)
frame.set_draw_handler(on_draw)
frame.start()

# timer to update
timer = simplegui.create_timer(500, update_game_of_life)
timer.start()

on_demo_toad()
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 29 Dec 2014 00:00:00 +0800</pubDate>
        <link>http://ironhead.bitbucket.com/2014/12/29/conways-game-of-life.html</link>
        <guid isPermaLink="true">http://ironhead.bitbucket.com/2014/12/29/conways-game-of-life.html</guid>
        
        <category>python</category>
        
        <category>programming</category>
        
        
      </item>
    
      <item>
        <title>Sketch: Long Hair Girl</title>
        <description>&lt;p&gt;&lt;img src=&quot;/assets/images/sketch-0000.jpg&quot; alt=&quot;Long Hair Girl&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 21 Dec 2014 00:00:00 +0800</pubDate>
        <link>http://ironhead.bitbucket.com/2014/12/21/sketch.html</link>
        <guid isPermaLink="true">http://ironhead.bitbucket.com/2014/12/21/sketch.html</guid>
        
        <category>sketch</category>
        
        
      </item>
    
      <item>
        <title>BaseX Quick Start</title>
        <description>&lt;h2 id=&quot;installation&quot;&gt;Installation&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://brewformulas.org/Basex&quot;&gt;brew install basex&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;If you want to change the datebase path, run “basexgui” in terminal and change it in preference.&lt;/li&gt;
  &lt;li&gt;command to start server: basexserver&lt;/li&gt;
  &lt;li&gt;command to start client: basexclient, default username and password are admin/admin.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;create-database-and-add-some-nodes&quot;&gt;Create Database and Add Some Nodes&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-xquery&quot;&gt;(: create a database and name it &quot;tv-shows&quot;. :)
(: attention: this command cleans the &quot;tv-shows&quot; database if it exist. :)
create db tv-shows

(: open the database whose name is tv-shows. :)
open tv-shows

(: add xml to the currently opened database at the path &quot;shows&quot;. :)
add to shows &amp;lt;shows&amp;gt;&amp;lt;show&amp;gt;&amp;lt;/show&amp;gt;&amp;lt;show&amp;gt;&amp;lt;/show&amp;gt;&amp;lt;show&amp;gt;&amp;lt;/show&amp;gt;&amp;lt;/shows&amp;gt;

(: list all database, there should be 1 resource under tv-shows database. :)
list

(: list all resources of tv-shows, :)
(: there should be 1 xml whose name is &quot;shows&quot;. :)
list tv-shows

(: get all &amp;lt;show/&amp;gt; node under &amp;lt;shows&amp;gt;&amp;lt;/shows&amp;gt;. :)
(: the result should be &amp;lt;show/&amp;gt;&amp;lt;show/&amp;gt;&amp;lt;show/&amp;gt;. :)
xquery for $s in shows/show return $s

(: get all &amp;lt;show/&amp;gt; nodes under shows, :)
(: add a new node &amp;lt;name/&amp;gt; to each one of them. :)
xquery for $s in shows/show return insert node &amp;lt;name/&amp;gt; into $s

(: watch the content of the currently opened database :)
(: it should be like this: :)
(: &amp;lt;shows&amp;gt; :)
(:   &amp;lt;show&amp;gt;&amp;lt;name/&amp;gt;&amp;lt;/show&amp;gt; :)
(:   &amp;lt;show&amp;gt;&amp;lt;name/&amp;gt;&amp;lt;/show&amp;gt; :)
(:   &amp;lt;show&amp;gt;&amp;lt;name/&amp;gt;&amp;lt;/show&amp;gt; :)
(: &amp;lt;/shows&amp;gt; :)
xquery *

(: insert a new node &amp;lt;rating/&amp;gt; into the first &amp;lt;show/&amp;gt; node under &amp;lt;shows/&amp;gt;. :)
(: attention: the first element is [1], not zero based! :)
xquery insert node &amp;lt;rating/&amp;gt; into shows/show[1]

(: insert a new node &amp;lt;rating/&amp;gt; into the last &amp;lt;show/&amp;gt; node under &amp;lt;shows/&amp;gt;. :)
xquery insert node &amp;lt;rating/&amp;gt; into shows/show[last()]

(: declare that $s is the second &amp;lt;show/&amp;gt; node under &amp;lt;shows/&amp;gt;, :)
(: insert a new &amp;lt;rating/&amp;gt; node into it :)
xquery let $s := shows/show[2] return insert node &amp;lt;rating/&amp;gt; into $s

(: delete the 1st node under &amp;lt;shows/&amp;gt; :)
(: try xquery * again and you should get: :)
(: &amp;lt;shows&amp;gt;                          :)
(:   &amp;lt;show&amp;gt;&amp;lt;name/&amp;gt;&amp;lt;rating/&amp;gt;&amp;lt;/show&amp;gt;  :)
(:   &amp;lt;show&amp;gt;&amp;lt;name/&amp;gt;&amp;lt;rating/&amp;gt;&amp;lt;/show&amp;gt;  :)
(: &amp;lt;/shows&amp;gt;                         :)
xquery delete node shows/show[1]

(: destroy the database &quot;tv-shows&quot;. :)
drop db tv-shows
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;update-a-node&quot;&gt;Update a Node&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-xquery&quot;&gt;create db tv-shows
open tv-shows
add to shows &amp;lt;shows&amp;gt;&amp;lt;show&amp;gt;&amp;lt;/show&amp;gt;&amp;lt;show&amp;gt;&amp;lt;/show&amp;gt;&amp;lt;/shows&amp;gt;

(: add attribute &#39;update&#39; with current datetime to &amp;lt;shows/&amp;gt; :)
xquery insert node attribute{&#39;update&#39;}{current-dateTime()} into shows

(: add attribute &#39;season&#39; to shows :)
xquery insert node attribute{&#39;seasons&#39;}{5} into shows/show[1]
xquery insert node attribute{&#39;seasons&#39;}{2} into shows/show[2]

(: add node &amp;lt;name/&amp;gt; to each show :)
xquery insert node &amp;lt;name&amp;gt;Game of Thrones&amp;lt;/name&amp;gt; into shows/show[1]
xquery insert node &amp;lt;name&amp;gt;Penny Dreadful&amp;lt;/name&amp;gt; into shows/show[2]

(: add &amp;lt;star/&amp;gt; to &quot;Game of Thrones&quot; :)
xquery insert node (&amp;lt;star&amp;gt;Lena Headey&amp;lt;/star&amp;gt;, &amp;lt;star&amp;gt;Peter Dinklage&amp;lt;/star&amp;gt;)
  into shows/show[1]

(: add &amp;lt;star/&amp;gt; to the node whose &amp;lt;name/&amp;gt; is Penny Dreadful :)
xquery for $s in shows/show where $s/name=&#39;Penny Dreadful&#39; return insert
  node (&amp;lt;star&amp;gt;Josh Hartnett&amp;lt;/star&amp;gt;,&amp;lt;star&amp;gt;ironhead&amp;lt;/star&amp;gt;) into $s

(: current contents                                 :)
(:  &amp;lt;shows update=&quot;2014-12-11T14:26:04.139+08:00&quot;&amp;gt;  :)
(:    &amp;lt;show seasons=&quot;5&quot;&amp;gt;                            :)
(:      &amp;lt;name&amp;gt;Game of Thrones&amp;lt;/name&amp;gt;                :)
(:      &amp;lt;star&amp;gt;Lena Headey&amp;lt;/star&amp;gt;                    :)
(:      &amp;lt;star&amp;gt;Peter Dinklage&amp;lt;/star&amp;gt;                 :)
(:    &amp;lt;/show&amp;gt;                                       :)
(:    &amp;lt;show seasons=&quot;2&quot;&amp;gt;                            :)
(:      &amp;lt;name&amp;gt;Penny Dreadful&amp;lt;/name&amp;gt;                 :)
(:      &amp;lt;star&amp;gt;Eva Green&amp;lt;/star&amp;gt;                      :)
(:      &amp;lt;star&amp;gt;Josh Hartnett&amp;lt;/star&amp;gt;                  :)
(:      &amp;lt;star&amp;gt;ironhead&amp;lt;/star&amp;gt;                       :)
(:    &amp;lt;/show&amp;gt;                                       :)
(:  &amp;lt;/shows&amp;gt;                                        :)
xquery *

(: find &amp;lt;show/&amp;gt; whose name is &#39;Penny Dreadful&#39; and delete the incorrect :)
(: star node &amp;lt;star&amp;gt;ironhead&amp;lt;/star&amp;gt;. :)
xquery for $x in shows/show where $x/name=&#39;Penny Dreadful&#39;
  return delete node $x/star[.=&#39;ironhead&#39;]

(: replace a &amp;lt;star/&amp;gt; node. :)
xquery for $s in shows/show where $s/name=&quot;Penny Dreadful&quot;
  return (replace node $s/star[.=&#39;Josh Hartnett&#39;] with
  &amp;lt;star&amp;gt;Timothy Dalton&amp;lt;/star&amp;gt;)

(: rename all &amp;lt;star/&amp;gt; node as &amp;lt;cast/&amp;gt; node :)
xquery for $s in shows/show/star return rename node $s as &#39;cast&#39;

(: copy the 2nd &amp;lt;show/&amp;gt; node, modify and return it. :)
(: there is nothing happened in the original node. :)
xquery copy $temp := shows/show[2] modify (insert node
  &amp;lt;star&amp;gt;Josh Hartnett&amp;lt;/star&amp;gt; into $temp) return $temp

(: should not find &amp;lt;star&amp;gt;Josh Hartnett&amp;lt;/star&amp;gt; in shows/show[2] :)
xquery *

drop db tv-shows
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;write-function---functional-programming&quot;&gt;Write Function - Functional Programming&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-xquery&quot;&gt;(: In test database, shows resource.
  &amp;lt;shows&amp;gt;
    &amp;lt;show name=&quot;Game of Thrones&quot;/&amp;gt;
  &amp;lt;/shows&amp;gt; :)

(: To declare function in this way, namespace must be local.
  node()* is type of node.
  node-name($n) returns name of $n.
  $n/@* returns all attributes of $n.
  element { node-name($n) }{ $n/@* } clone $n :)

(: result: &amp;lt;show name=&quot;Game of Thrones&quot;/&amp;gt; :)

xquery declare function local:clone($n as node()*) as node()* {
  element { node-name($n) }{ $n/@* }
};
let $x := doc(&#39;test/shows&#39;)/shows/show[1]
return local:clone($x)

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;get-elements-childlessly&quot;&gt;Get Elements Childlessly&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-xquery&quot;&gt;(: In test database, shows resource.
  &amp;lt;shows&amp;gt;
    &amp;lt;show name=&quot;Game of Thrones&quot;/&amp;gt;
    &amp;lt;show name=&quot;Penny Dreadful&quot;/&amp;gt;
    &amp;lt;movie name=&quot;The Maze Runner&quot;/&amp;gt;
  &amp;lt;/shows&amp;gt;
:)

(: Result:
  &amp;lt;root&amp;gt;
    &amp;lt;show name=&quot;Game of Thrones&quot;/&amp;gt;
    &amp;lt;show name=&quot;Penny Dreadful&quot;/&amp;gt;
    &amp;lt;movie name=&quot;The Maze Runner&quot;/&amp;gt;
  &amp;lt;/root&amp;gt;
:)

xquery declare function local:clone($n as node()*) as node()* {
  element { node-name($n) }{ $n/@* }
};
let $x := doc(&#39;test/shows&#39;)/shows/*
return &amp;lt;root&amp;gt;{
  for $c in $x return local:clone($c)
}&amp;lt;/root&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Wed, 10 Dec 2014 00:00:00 +0800</pubDate>
        <link>http://ironhead.bitbucket.com/2014/12/10/basex-quick-start.html</link>
        <guid isPermaLink="true">http://ironhead.bitbucket.com/2014/12/10/basex-quick-start.html</guid>
        
        <category>database</category>
        
        
      </item>
    
      <item>
        <title>Arduino: Snake on 8x8 LED Matrix</title>
        <description>&lt;h2 id=&quot;source-code-on-githubhttpsgithubcomimironheadarduino-practice&quot;&gt;&lt;a href=&quot;https://github.com/imironhead/arduino-practice&quot;&gt;Source Code on Github&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/arduino_snake_v1.jpg&quot; alt=&quot;arduino_snake_v1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://youtu.be/VC2F66MZuh0&quot;&gt;YouTube&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;hardware-required&quot;&gt;Hardware Required&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Arduino Board&lt;/li&gt;
  &lt;li&gt;8x8 LED Matrix&lt;/li&gt;
  &lt;li&gt;Infrared Sensor&lt;/li&gt;
  &lt;li&gt;220 ohm resistor&lt;/li&gt;
  &lt;li&gt;Hook-up wires&lt;/li&gt;
  &lt;li&gt;breadboard&lt;/li&gt;
  &lt;li&gt;remote control&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;library&quot;&gt;Library&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/coopermaa/Arduino-IRremote&quot;&gt;Arduino-IRremote&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;how-to-receive-ir&quot;&gt;How to Receive IR&lt;/h3&gt;

&lt;p&gt;Get &lt;a href=&quot;https://github.com/coopermaa/Arduino-IRremote&quot;&gt;Arduino-IRremote&lt;/a&gt;, change forlder name to ‘IRremote’ and put it into Arduino IDE’s subdirectory. If you work on OS X, find Arduino.app in Applications folder, open its context menu and select ‘Show Package Contents’. Then put ‘IRremote’ under ‘Arduino.app/contents/java/libraries/’. Re-launch Arduino IDE and you’ll find ‘IRremote’ examples.&lt;/p&gt;

&lt;p&gt;To make sure we can receive infrared singnals, prepare a circuit to test it. A infrared sensor has 3 pins, connect the middle pin to ground. Connect the other 2 pins to 3.3v and pin 11 on Arduino. Between the pin of sensor and 3.3v pin, connect a 220 ohm resistor. Then upload the IRrecvDemo code to Arduino. If everything is fine, you could read something on serial monitor.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/arduino-ir-sensor.jpg&quot; alt=&quot;IR sensor&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;left pin -&amp;gt; 11 pin of Arduino&lt;/li&gt;
  &lt;li&gt;middle pin -&amp;gt; GND of Arduino&lt;/li&gt;
  &lt;li&gt;right pin -&amp;gt; 220 ohm resistor -&amp;gt; 3.3v pin of Arduino&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the source code of snake, A0 pin is used instead 11 pin.&lt;/p&gt;

&lt;h3 id=&quot;x8-led-matrix&quot;&gt;8x8 LED Matrix&lt;/h3&gt;

&lt;p&gt;Play the &lt;a href=&quot;http://arduino.cc/en/Tutorial/RowColumnScanning&quot;&gt;Row Column Scanning example&lt;/a&gt;, I have not run this example but connect the circuit as it.&lt;/p&gt;

&lt;p&gt;To light up a LED, we have to connect it to a HIGH pin and a LOW pin. But there are only 16 pins on the 8x8 LED matrix which has only 2^16 combinations. To simulate 2^64 combinations, we have to do something like &lt;a href=&quot;http://arduino.cc/en/Tutorial/PWM&quot;&gt;PWM&lt;/a&gt;. For example, if we want to light up LED in (1, 1), set pin of 1st row to HIGH and set pin of 1st column to LOW can tuen on the LED. In each loop, we turn on and off the LEDs.&lt;/p&gt;

&lt;p&gt;The Refresh method is used to display the game on the LED matrix. In order to make the display stable, we need a stable refresh rate in this method. In other words, to display a pattern stablely, we must spend the same time period on each loop and LED. That’s why I turn off some LEDs twice (set a pin to HIGH twice).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;void Refresh() {
  int row, col, msk;

  for (row = 0; row &amp;lt; 8; ++row) {
    msk = this-&amp;gt;masks[row];

    digitalWrite(SnakeBoard::ROW[row], HIGH);

    for (col = 0; col &amp;lt; 8; ++col) {
      if (msk &amp;amp; (1 &amp;lt;&amp;lt; col)) {
        digitalWrite(SnakeBoard::COL[col], LOW);
        digitalWrite(SnakeBoard::COL[col], HIGH);
      } else {
        digitalWrite(SnakeBoard::COL[col], HIGH);
        digitalWrite(SnakeBoard::COL[col], HIGH);
      }
    }

    digitalWrite(ROW[row], LOW);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;the-final-result&quot;&gt;The Final Result&lt;/h3&gt;

&lt;p&gt;To run the source code, you have to define the singals from infrared sensor. You can find the correct value by running the ‘IRremote’ example.&lt;/p&gt;

&lt;p&gt;Now we can combine a circuit from ‘IRremote’ and ‘Row Column Scanning’ example. Remember to change the data pin of infrared sensor from 11 to A0. Then upload the snake to Arduino and start to play!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;#define REMOTE_UP               (0x85AEFD19)
#define REMOTE_DOWN             (0xB66D73CD)
#define REMOTE_RIGHT            (0x5C5C901D)
#define REMOTE_LEFT             (0x8F890759)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;update-20141127&quot;&gt;Update 20141127&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/arduino_snake_v2.jpg&quot; alt=&quot;arduino_snake_v2&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://arduino.cc/en/tutorial/ShiftOut&quot;&gt;ShiftOut Example&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/imironhead/arduino-practice/tree/master/arduino-snake-v2&quot;&gt;Github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Reconnect all column pins of the LED matrix to a 74HC595 chip (because I have only one in hand :)). Refresh method become:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;void Refresh() {
  for (int row = 0; row &amp;lt; 8; ++row) {
    digitalWrite(SnakeBoard::ROW[row], HIGH);

    digitalWrite(PIN_SIFTING_OUT_LATCH, LOW);
    shiftOut(
      PIN_SIFTING_DATA,
      PIN_SIFTING_CLOCK,
      LSBFIRST,
      ~(unsigned char)this-&amp;gt;masks[row]);
    digitalWrite(PIN_SIFTING_OUT_LATCH, HIGH);

    digitalWrite(PIN_SIFTING_OUT_LATCH, LOW);
    shiftOut(PIN_SIFTING_DATA, PIN_SIFTING_CLOCK, MSBFIRST, 255);
    digitalWrite(PIN_SIFTING_OUT_LATCH, HIGH);

    digitalWrite(ROW[row], LOW);
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 25 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://ironhead.bitbucket.com/2014/11/25/arduino-snake.html</link>
        <guid isPermaLink="true">http://ironhead.bitbucket.com/2014/11/25/arduino-snake.html</guid>
        
        <category>arduinno</category>
        
        
      </item>
    
      <item>
        <title>Regular Number Generator</title>
        <description>&lt;p&gt;aka “Hamming numbers”, “ugly numbers”.&lt;/p&gt;

&lt;p&gt;Prime factors of those numbers are 2, 3 or 5.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;Ugly = 2^a * 3^b * 5^c&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
0 &lt;= a, b, c %]]&gt;&lt;/script&gt;

&lt;p&gt;How to implement?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1 is the first ugly number.&lt;/li&gt;
  &lt;li&gt;If R is an ugly number, then 2&lt;em&gt;R, 3&lt;/em&gt;R and 5*R are all ugly numbers as well.&lt;/li&gt;
  &lt;li&gt;There are many ugly numbers so we need a priority queue to select them in ascending order.&lt;/li&gt;
  &lt;li&gt;Suppose R equals to 2^a * 3^b, should 2&lt;em&gt;R be pushed into the priority queue? Considering another number R’ which equals to 2^(a+1) * 3^(b-1), we known that R’ &amp;lt; R. So even if both of R’ &amp;amp; R are in the priority queue, R’ would be selected before R. When R’ is selected, 3&lt;/em&gt;R’ should be pushed into priority queue at the same time. Which means 3&lt;em&gt;R’ is pushed into queue before 2&lt;/em&gt;R, so we do not have to push 2&lt;em&gt;R again (3&lt;/em&gt;R’ = 2^(a+1) * 3^b = 2*R).&lt;/li&gt;
  &lt;li&gt;So every time when a number R is selected, new ugly number should be generated by multiply the selected number with a new factor P, and P must greater or equal to the largest prime factor of R.&lt;/li&gt;
  &lt;li&gt;To illustrate the idea, build a tree with root node 1 (the first ugly number). All node values in this tree are their parent values multiple 2, 3, or 5 (e.g. children of 1 are 2, 3 and 5. children of 2 are 2&lt;em&gt;2, 2&lt;/em&gt;3 and 2*5. etc.). Remove the duplicated numbers and selected remains in ascending order.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;


struct Generator {
  priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt;&amp;gt;  pool;

  Generator() {
    this-&amp;gt;pool.push(1);
  }

  int Next() {
    int number = this-&amp;gt;pool.top();

    this-&amp;gt;pool.pop();

    if (number % 5 == 0) {
      this-&amp;gt;pool.push(number * 5);
    } else if (number % 3 == 0) {
      this-&amp;gt;pool.push(number * 3);
      this-&amp;gt;pool.push(number * 5);
    } else {
      this-&amp;gt;pool.push(number * 2);
      this-&amp;gt;pool.push(number * 3);
      this-&amp;gt;pool.push(number * 5);
    }

    return number;
  }
};

int main() {
  Generator g;

  for (int i = 0; i &amp;lt; 100; ++i) {
    cout &amp;lt;&amp;lt; g.Next() &amp;lt;&amp;lt; endl;
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Wed, 12 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://ironhead.bitbucket.com/2014/11/12/regular-number-generator.html</link>
        <guid isPermaLink="true">http://ironhead.bitbucket.com/2014/11/12/regular-number-generator.html</guid>
        
        <category>c++</category>
        
        <category>programming</category>
        
        
      </item>
    
  </channel>
</rss>
